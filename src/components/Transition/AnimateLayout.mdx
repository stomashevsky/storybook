import { Canvas, Controls, Meta, Subtitle, Title, ArgTypes } from "@storybook/blocks"

import * as AnimateLayoutStories from './AnimateLayout.stories'
 
<Meta of={AnimateLayoutStories} />
 
<Title>AnimateLayout</Title>
<Subtitle>Animate width & height of components as they mount and unmount</Subtitle>

### Usage

```jsx
import { AnimateLayout } from "base-ui/components/Transition"
```

### Overview

`<AnimateLayout>` is an abstraction around `<TransitionGroup>` for batteries-included transition animations that can also animate `height` and `width` of transitions.

All of the same properties from `<Animate>` are supported here, as well as new properties for customizing the timing of layout transitions - `layoutEnter`, `layoutExit`, and `layoutMove`.

### When to use

`<AnimateLayout>` is great for transitions should naturally affect layout of surrounding DOM nodes.

These animations should be for transitioning between two states that occupy _the same space_, such as:

- _nothing_ → Component
- Component → _nothing_
- Component → AnotherComponent

## Examples

### Height

By default, `<AnimateLayout>` animates the `height` of a component as it enters and exits the DOM.

<div className="story-example">
  <Canvas
    of={AnimateLayoutStories.SimpleHeight}
    source={{
      code: `
<>
  <Line className="w-full h-12" />
  <AnimateLayout transitionClassName="pt-4">
    {show && <PrimaryLine key="s" className="w-full h-[80px]" />}
  </AnimateLayout>
  <Line className="w-full h-12 mt-4" /> 
</>
`,
    }}
  />
</div>

### Width

You can also animate the `width` of components by passing `dimension="width"`.

<div className="story-example">
  <Canvas
    of={AnimateLayoutStories.SimpleWidth}
    source={{
      code: `
<div className="flex">
  <Square className="w-[200px] h-[200px]" />
  <AnimateLayout
    dimension="width"
    transitionClassName="pl-6"
    enter={{ delay: 200 }}
    layoutExit={{ delay: 75 }}
  >
    {show && <PrimarySquare key="s" className="w-[200px] h-[200px]" />}
  </AnimateLayout>
  <Square className="w-[200px] h-[200px] ml-6" />
</div>
`,
    }}
  />
</div>

### Accordion

Accordion items are a great example of dynamically introducing content that affect the `height` of surrounding DOM nodes.

The following example shows how to wrap accordion item content with `<AnimateLayout>` to create a smooth animation.

<Canvas
  of={AnimateLayoutStories.Accordion}
  layout="padded"
  source={{
    code: `
<AnimateLayout
  enter={{ y: 0, delay: 150, duration: 450 }}
  exit={{ y: -8 }}
  layoutEnter={{ duration: 400 }}
>
  {open && (
    <div key="content" className="pb-4 text-secondary">
      {children}
    </div>
  )}
</AnimateLayout>
`,
  }}
/>

### Talk button

When animating `width`, the `height` of the component should be consistent.

The key to making this animation work is using `transitionClassName` to recreate the flexbox structure that `<Button>` normally provides, and stretching it to the ful height of the button.

<Canvas
  of={AnimateLayoutStories.TalkButton}
  source={{
    code: `
<Button
  color={recording ? "danger" : "primary"}
  size="xl"
  iconSize="lg"
  onClick={handleClick}
  loading={sending}
>
  <AnimateLayout dimension="width" transitionClassName="h-full flex items-center gap-2">
    {recording ? (
      <ArrowUp key="recording" />
    ) : (
      <Fragment key="record">
        <Wave /> Talk
      </Fragment>
    )}
  </AnimateLayout>
</Button>
`,
  }}
/>

### Gotchas

- `<AnimateLayout>` provides a wrapping element, which `className` and layout transition properties are applied to.
- Avoid box model properties on `className`, like `margin`, `padding`, `border`.
  - These are additive to `height: 0;` empty state, and cannot be properly animated.
- Avoid `box-shadow` on `className`, as it will be visible during empty state.
- `margin` cannot be animated, and should be avoided on the children (`transitionClassName`). Use padding instead, which is intrinsic to the `height` calculation!

## Props

<ArgTypes of={AnimateLayoutStories.SimpleHeight} />
